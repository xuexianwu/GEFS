########################### EXENSPOST ################################
echo "------------------------------------------------"
echo "Ensemble Postprocessing"
echo "Create enspost ensstat ensppf files"
echo "------------------------------------------------"
echo "History: MAY 1997 - First implementation of this new script."
echo "AUTHOR: Yuejian Zhu (wd20yz)"
echo "Modified by: Mary Jacobs"
echo "Modified by: Yuejian Zhu ---- October 1997"
echo "Modified by: Maxine Brown for Yuejian Zhu ---- November 1997"
echo "Modified by: David Michaud to port to IBM SP ---- September 1999"
echo "Modified by: Larry Sager to add spaghetti ensembles -- Feb 2000"
echo "Modified by: Yuejian Zhu to add high resolution archive---- June 2000"
echo "Modified by: Richard Wobus to add ensstat statistics---- September 2001"
echo "Modified by: Yuejian Zhu to add more vars, 6-hr interval fcst output,"
echo "             apply to T00Z, T06Z, T12Z and T18Z cycles,               "
echo "             no more ensppf production                                "
echo "             move pqpf to ensstat process                ---- May 2003"
echo "Modified by: Richard Wobus to add more variables ---- MARCH 2004"
echo "Modified by: Richard Wobus to add 192hr zsfc  ---- August 2004"
echo "Modified by: Richard Wobus reorganize by hour  ---- March 2006"
echo "Modified by: Richard Wobus separate enspost from avg/spr ---- June 2011"
echo "Modified by: Bo Cui and Dingchen Hou change to grib2 operations  ---- Nov. 2014":w

### need pass the values of CYC, YMD, DATA, COMIN and COMOUT

if [[ ! -d $DATA ]]; then
	mkdir -p $DATA
fi

set -x

cd $DATA

#####################################
# Define ensemble message switch
#   iens_msg=0 will add ensemble extension message
#   iens_msg=1 do not need to add ensemble extension message
#              only if evry members (include GFS) have
#              extension message
#####################################
export iens_msg=1

#####################################
# Define Script/Exec Variables
#####################################

#export WGRIB=${WGRIB:-$EXECgrib/wgrib}
#export GRBINDEX=${GRBINDEX:-$EXECgrib/grbindex}
#export COPYGB=${COPYGB:-$EXECgrib/copygb}
#export WGRIB2=${WGRIB2:-$EXECgrib/wgrib2}
#export GRB2INDEX=${GRB2INDEX:-$EXECgrib/grb2index}
#export COPYGB2=${COPYGB2:-$EXECgrib/copygb2}
#export CNVGRIB=${CNVGRIB:-$EXECgrib/cnvgrib}

export ENSPPF=$USHgefs/global_ensppf.sh
export ENSSTAT=$EXECgefs/gefs_ensstat
export ENSPQPF=$USHgefs/global_enspqpf.sh

#####################################
# START TO DUMP DATA FOR $cycle CYCLE
# START TO DUMP DATA FROM PGB FORECAST FILES
#####################################

varlout=" \
ensppf pqpf  pqsf  pqff  pqrf  pqif \
"

if test "$SENDCOM" = 'YES'; then
	for file in enspost${ext_h} ensstat${ext_h}; do
		#   for FIELD in $varlboth $varlnostat $varlout
		for FIELD in $epnamhr $epnamlr $varlout; do
			if [ -s $COMOUT/$cyc/ensstat/$file.${cycle}.${FIELD} ]; then
				rm $COMOUT/$cyc/ensstat/$file.${cycle}.${FIELD}
				rm $COMOUT/$cyc/ensstat/$file.${cycle}.${FIELD}i
			fi
			if [ -s $COMOUT/$cyc/ensstat/$file.${cycle}.${FIELD}hr ]; then
				rm $COMOUT/$cyc/ensstat/$file.${cycle}.${FIELD}hr
				rm $COMOUT/$cyc/ensstat/$file.${cycle}.${FIELD}hri
			fi
		done # for FIELD in $epnamhr $epnamlr $varlout
	done # for file in enspost${ext_h} ensstat${ext_h}
fi # test "$SENDCOM" = 'YES'

memberlist="gfs c00"
#DHOU 04/19/2012 Add this block to avoid gfs for "dev" jobs
if [[ $envir = dev ]]; then
	memberlist="c00"
fi

(( imem = 0 ))
while (( imem < npert )); do
	(( imem = imem + 1 ))
	if (( imem < 10 )); then
		imem=0$imem
	fi
	memberlist="$memberlist p$imem"
done # while (( imem < npert ))
echo memberlist=$memberlist


echo
echo "`date`  ==== START OF HOURLY PROCESSING OF PGB FORECAST FILES ====="
echo

SLEEP_LOOP_MAX=`expr $SLEEP_TIME / $SLEEP_INT`

export fh=$SHOUR
#export  (( fh = SHOUR ))
if test $fh -lt 10 -a $fh -gt 0; then
	export fhr="0$fh"
fi
#if test $fh -lt 100 -a $fh -gt 0
#then
#   export fhr="0$fh"
#fi

############################################################
# Loop Through the Post Forecast Files
############################################################
(( nfilesprev = 9999 ))
foundgfs=no
while test $fh -le $FHOUR; do
	#  the order here should correspond to the order in
	#  which the pgrb files are produced by the post
	# for res in lr hr p5

        #Change the $fh value from 2 digit to 3 digit 
	if test $fh -lt 100; then
		export fh="0$fh"
	fi

	for res in lr; do
		if [[ $res = lr ]]; then
			#EXT=".2"
			#FXT=
			#lr=lr
			#ext_h=
			EXT=
			FXT=.2p50.
			lr=2p5
			ext_h=
			nenspost=$nenspostlr
			lfm=$lfmlr
			set -A enspostnam x $epnamlr
			set -A enspostvar x $epvarlr
			set -A enspostlvt x $eplvtlr
			set -A enspostlev x $eplevlr
		elif [[ $res = hr ]]; then
			EXT=
			FXT=
			lr=
			ext_h=1p
			nenspost=$nensposthr
			lfm=$lfmhr
			set -A enspostnam x $epnamhr
			set -A enspostvar x $epvarhr
			set -A enspostlvt x $eplvthr
			set -A enspostlev x $eplevhr
		elif [[ $res = p5 ]]; then  
			EXT=
			lr=p5
			FXT=p5
			ext_h=p5
			nenspost=$nenspostp5
			lfm=$lfmp5
			set -A enspostnam x $epnamp5
			set -A enspostvar x $epvarp5
			set -A enspostlvt x $eplvtp5
			set -A enspostlev x $eplevp5
		else
			echo res= $res, NOT expected
		fi # [[ $res = lr ]]

		###############################
		# Start Looping for the
		# existence of the pgrba files
		###############################
		set +x
		ic=1
		while [ $ic -le $SLEEP_LOOP_MAX ]; do
			nfiles=0
			nmem=0
			foundall=yes
			previncr=no
			for mem in $memberlist; do
				(( nmem = nmem + 1 ))
				#       testfile=$COMIN/$cyc/pgrba$lr/ge${mem}.${cycle}.pgrbaif$fh$EXT$cfsuffix
				testfile=$COMIN/$cyc/pgrb2a$lr/ge${mem}.${cycle}.pgrb2a$FXT\f$fh$EXT${cfsuffix}.idx
				if test -f $testfile; then
					echo testfile=$testfile found
					(( nfiles = nfiles + 1 ))
					if [[ $mem = gfs ]]; then
						foundgfs=yes
					fi
					echo mem=$mem nfiles=$nfiles foundgfs=$foundgfs foundall=$foundall previncr=$previncr ic=$ic fh=$fh found
				else # test -f $testfile
					echo testfile=$testfile not found
					if [[ $mem = gfs ]] && [[ $foundgfs = yes ]] && (( fh > 180 )) && (( fh % 12 > 0 )); then
						previncr=yes
					else
						foundall=no
					fi
					echo mem=$mem nfiles=$nfiles foundgfs=$foundgfs foundall=$foundall previncr=$previncr ic=$ic fh=$fh not found
				fi # test -f $testfile
			done # for mem in $memberlist

			if [[ $foundall = yes ]]; then
				if [[ $previncr = yes ]]; then
					(( nfilesprev = nfiles + 1 ))
				else
					(( nfilesprev = nfiles ))
				fi
				echo Search process ends nfilesprev=$nfilesprev foundgfs=$foundgfs foundall=$foundall previncr=$previncr ic=$ic fh=$fh
				echo Process all $nfiles members
				break
			else # [[ $foundall = yes ]]
				if (( nfiles < nfilesprev )); then
					ic=`expr $ic + 1`
					sleep $SLEEP_INT
				else
					if [[ $previncr = yes ]]; then
						(( nfilesprev = nfiles + 1 ))
					else
						(( nfilesprev = nfiles ))
					fi
					echo Search process ends nfilesprev=$nfilesprev foundgfs=$foundgfs foundall=$foundall previncr=$previncr ic=$ic fh=$fh
					echo Continue processing with $nfiles members
					break
				fi # (( nfiles < nfilesprev ))
			fi # [[ $foundall = yes ]]
			###############################
			# If we reach this point assume
			# fcst job never reached restart
			# period and error exit
			###############################
			echo $nfiles out of $nmem members were found
			if [ $ic -eq $SLEEP_LOOP_MAX ]; then

				###############################
				# MODIFY THIS STATEMENT TO
				# ALLOW A DIFFERENT NUMBER OF
				# MEMBERS TO BE MISSING
				#
				# CURRENTLY ALLOWS ONE MISSING
				###############################
				#(( nfilesmin = nmem - 1 ))
				(( nfilesmin = nmem ))

				if (( nfiles < nfilesmin )); then
					echo Search process FAILS nfilesprev=$nfilesprev foundgfs=$foundgfs foundall=$foundall previncr=$previncr ic=$ic fh=$fh
					echo $nfiles IS FEWER THAN $nfilesmin MEMBERS
					export err=9
					err_chk
				else # (( nfiles < nfilesmin ))
					(( nfilesprev = nfiles ))
					echo Search process ends nfilesprev=$nfilesprev foundgfs=$foundgfs foundall=$foundall previncr=$previncr ic=$ic fh=$fh
					echo Continue after timeout with $nfiles members
					break
				fi # (( nfiles < nfilesmin ))
			fi # [ $ic -eq $SLEEP_LOOP_MAX ]
		done # while [ $ic -le $SLEEP_LOOP_MAX ]
		set -x

		msg="Starting ensstat generation for fhr=$fh"
		postmsg "$jlogfile" "$msg"

		#
		#  Make namelist file
		#
		echo " &namdim" >namin
		#   echo " nmemdim=100", >>namin
		#   echo " nenspostdim=100", >>namin
		echo " lfdim=${lfm}", >>namin
		echo " /" >>namin
		echo " &namens" >>namin

		parmlist=$PARMgefs/gefs_enspost_grb2.parm
		ifile=0
		for mem in $memberlist; do
			#DHOU, 20141028, select required variables from pgrb2a files
			if [[ "$mem" != "gfs" || $fh -le $gfsfhmaxh || ` expr $fh % 12 ` -eq 0 ]]; then
				pgtem=$COMIN/$cyc/pgrb2a$lr/ge${mem}.${cycle}.pgrb2a$FXT\f$fh$EXT$cfsuffix
				$WGRIB2 -s $pgtem | grep -F -f $parmlist | $WGRIB2 $pgtem -s -i -grib pgrb2a_$mem 
				#DHOU 20141028
				(( ifile = ifile + 1 ))
				iskip=0
				#     echo " cfipg($ifile)"=\"$COMIN/$cyc/pgrba$lr/ge${mem}.${cycle}.pgrbaf$fh$EXT$cfsuffix\", >>namin
				#     echo " cfipi($ifile)"=\"$COMIN/$cyc/pgrba$lr/ge${mem}.${cycle}.pgrbaif$fh$EXT$cfsuffix\", >>namin
				#     echo " cfipg($ifile)"=\"$COMIN/$cyc/pgrb2a$lr/ge${mem}.${cycle}.pgrb2a$FXT\f$fh$EXT$cfsuffix\", >>namin
				echo " cfipg($ifile)"="pgrb2a_$mem", >>namin
				echo " iskip($ifile)"=$iskip, >>namin
			fi # [[ "$mem" != "gfs" || $fh -le $gfsfhmaxh || ` expr $fh % 12 ` -eq 0 ]]
		done # for mem in $memberlist

		echo " nfiles=$ifile", >>namin
		echo " nenspost=${nenspost}", >>namin

		(( ienspost = 0 ))
		(( iunitouts = 52 ))
		#   while (( ienspost < nenspost ))
		while (( ienspost < 0 )); do
			(( ienspost = ienspost + 1 ))
			(( iunitouta = iunitouts + 1 ))
			(( iunitouts = iunitouts + 2 ))
			echo " ivar($ienspost)"=${enspostvar[$ienspost]}, >>namin
			echo " ilev($ienspost)"=${enspostlev[$ienspost]}, >>namin
			echo " ilvt($ienspost)"=${enspostlvt[$ienspost]}, >>namin
			#     echo " cfopg($ienspost)"=\"enspost${ext_h}.$cycle.${enspostnam[$ienspost]}\", >>namin
			echo " cfotg($ienspost)"=\"ensstat${ext_h}.$cycle.${enspostnam[$ienspost]}\", >>namin
		done # while (( ienspost < 0 ))

		#   echo " cfoag"=\"dummy.geavg.$cycle.pgrbaf$fh$EXT$cfsuffix\", >>namin
		#   echo " cfosg"=\"dummy.gespr.$cycle.pgrbaf$fh$EXT$cfsuffix\" >>namin
		echo " cfopg1"="ensstat", >>namin
		echo " cfopg2"="ensstat", >>namin
                echo " navg_min"=${navg_min} >>namin

		echo ' /' >>namin

		echo
		cat namin
		echo

		echo "####################### `date` $fh $res ensstat begin" >$pgmout.$res$fh
		$ENSSTAT <namin | fold -w 2000 >$pgmout.$res$fh
		export err=$?; err_chk
		echo "####################### `date` $fh $res ensstat end">>$pgmout.$res$fh
		#DHOU 20141028 Separate the enspost variables in to individual files
		for var in $postvarlist; do
			case $var in
				z500) TEXT='HGT:500 mb';;
				z1000) TEXT='HGT:1000 mb';;
				t850) TEXT='TMP:850 mb';;
				u250) TEXT='UGRD:250 mb';;
				v250) TEXT='VGRD:250 mb';;
				u850) TEXT='UGRD:850 mb';;
				v850) TEXT='VGRD:850 mb';;
				t2m) TEXT='TMP:2 m a';;
				u10m) TEXT='UGRD:10 m a';;
				v10m) TEXT='VGRD:10 m a';;
				rh700) TEXT='RH:700 mb' ;;
				prmsl) TEXT='PRMSL:mean';;
				prcp) TEXT='APCP:surface';;
				snow) TEXT='CSNOW:surface';;
				rain) TEXT='CRAIN:surface';;
				icep) TEXT='CICEP:surface';;
				frzr) TEXT='CFRZR:surface';;
                                u200) TEXT='UGRD:200 mb';;
                                v200) TEXT='VGRD:200 mb';;
                                olr) TEXT='ULWRF:top of atmosphere';;
			esac # $var
			echo $var  $TEXT  
			for mem in $memberlist; do
				if [ -s pgrb2a_$mem ]; then
					$WGRIB2 -s pgrb2a_$mem | grep "$TEXT" | $WGRIB2 pgrb2a_$mem -i -append -grib enspost_grb2${ext_h}.$cycle.$var 
				fi
			done # for mem in $memberlist
			$WGRIB2 -s ensstat | grep "$TEXT" | $WGRIB2 ensstat -i -append -grib ensstat_grb2${ext_h}.$cycle.$var 
		done # for var in $postvarlist 
		rm pgrb2a* ensstat
		#DHOU 20141028

		for fhout in $statoutfhlist; do
			if (( fh == fhout )); then
				cat $pgmout.$res$fh >> $pgmout
			else
				lines=`cat $pgmout.$res$fh| wc -l`
				lobeg=5
				loend=40
				echo lines=$lines lobeg=$lobeg loend=$loend
				(( lskip = lines - lobeg - loend ))
				if (( lskip > 100 )); then
					head -$lobeg $pgmout.$res$fh >>$pgmout
					echo "####################### $lskip Lines Skipped">>$pgmout
					tail -$loend $pgmout.$res$fh >>$pgmout
				else
					cat $pgmout$res.$fh >> $pgmout
				fi
			fi # (( fh == fhout ))
		done # for fhout in $statoutfhlist
	done # for res in lr

	export fh=`expr $fh + $FHINC`
	if test $fh -lt 10; then
		export fh="0$fh"
	fi
done # while test $fh -le $FHOUR

echo ###############################`date` cat $pgmout begin
cat $pgmout
echo ###############################`date` cat $pgmout end

echo
echo "`date`  ==== END  OF  HOURLY PROCESSING OF PGB FORECAST FILES ====="
echo

# check for missing or zero-length output files

for file in $postvarlist; do
	if [[ -s enspost_grb2${ext_h}.$cycle.${file} ]]; then
		ls -al enspost_grb2${ext_h}.$cycle.${file}
	else
		echo output file enspost_grb2${ext_h}.$cycle.${file} IS MISSING
		export err=9
		err_chk
	fi
done # for file in $postvarlist

# Moving  output files to /com directory

if [ "$SENDCOM" = "YES" ]; then
	for file in $postvarlist; do
		mv enspost_grb2${ext_h}.$cycle.${file}  $COMOUT/$cyc/ensstat/enspost_grb2${ext_h}.${cycle}.${file}
		mv ensstat_grb2${ext_h}.$cycle.${file}  $COMOUT/$cyc/ensstat/ensstat_grb2${ext_h}.${cycle}.${file}
	done # for file in $postvarlist
fi # [ "$SENDCOM" = "YES" ]

#DHOU, 05/13/2015, added this block for gefs_cqpf trigger
ecflow_client --event enspost_grb2_ready

#
# create pqpf 24h and probabilistic precip forecast files
#

## part (1a): calculate PQPF (named ensppf ) for each 24 hours period,
## for 23 ens members 
## write out with ensemble extended messages
##
#
if test "$cycle" = "skipthis"; then
#if test "$cycle" = "t00z"; then
	#  $ENSPPF $COMOUT/$cyc/ensstat/enspost.$cycle.prcp $COMOUT/$cyc/ensstat/enspost${ext_h}.$cycle.prcpi ensppf${ext_h}.$PDY$cyc
	$ENSPPF $COMOUT/$cyc/ensstat/enspost_grb2.$cycle.prcp ensppf${ext_h}.$PDY$cyc.grib2  $npert
	$WGRIB2 ensppf${ext_h}.$PDY$cyc.grib2 -s >ensppf${ext_h}.$PDY$cyc.grib2.idx 

	###########################
	# Convert to grib1 format:
	###########################
	$CNVGRIB -g21 ensppf${ext_h}.$PDY$cyc.grib2 ensppf${ext_h}.$PDY$cyc
	ls -lt ensppf${ext_h}.$PDY$cyc.grib2 ensppf${ext_h}.$PDY$cyc
	$WGRIB2 -s ensppf${ext_h}.$PDY$cyc.grib2
	$GRBINDEX ensppf${ext_h}.$PDY$cyc ensppf${ext_h}i.$PDY$cyc

	# check for missing or zero-length output files

	if [[ -s ensppf${ext_h}.$PDY$cyc.grib2 ]]; then
		ls -al ensppf${ext_h}.$PDY$cyc.grib2
	else
		echo output file ensppf${ext_h}.$PDY$cyc.grb2 IS MISSING
		export err=9
		err_chk
	fi # [[ -s ensppf${ext_h}.$PDY$cyc.grib2 ]]

	if [ $SENDCOM = "YES" ]; then
		cp ensppf${ext_h}.$PDY$cyc $COMOUT/$cyc/ensstat/ensstat${ext_h}.$cycle.pqpf_24h
		cp ensppf${ext_h}i.$PDY$cyc $COMOUT/$cyc/ensstat/ensstat${ext_h}.$cycle.pqpfi_24h

		cp ensppf${ext_h}.$PDY$cyc.grib2 $COMOUT/$cyc/ensstat/ensstat${ext_h}.$cycle.pqpf_24h.grib2
		cp ensppf${ext_h}.$PDY$cyc.grib2.idx $COMOUT/$cyc/ensstat/ensstat${ext_h}.$cycle.pqpf_24h.grib2.idx
	fi  #[ $SENDCOM = "YES" ]
	if [ "$SENDDBN" = "YES" ]; then
		$DBNROOT/bin/dbn_alert MODEL ENS_STAT_GB2 $job $COMOUT/$cyc/ensstat/ensstat${ext_h}.$cycle.pqpf_24h.grib2
		$DBNROOT/bin/dbn_alert MODEL ENS_STAT_GB2_WIDX $job $COMOUT/$cyc/ensstat/ensstat${ext_h}.$cycle.pqpf_24h.grib2.idx
	fi # [ "$SENDDBN" = "YES" ]
fi # test "$cycle" = "t00z"

# part (1b): probabilistic forecasts ( PQPF, PQRF, PQFF, PQSF and PQIF )
export CDATE=$PDY$cyc; 
#$ENSPQPF

#for file in pqpf pqrf pqff pqsf pqif; do
#	$CNVGRIB -g21 $DATA/$file $DATA/$file\_grb1
#	$WGRIB2 $DATA/$file -s >$DATA/$file\.idx
#	$GRBINDEX $DATA/$file\_grb1 $DATA/${file}i_grb1
#	if [ $SENDCOM = "YES" ]; 	then
#		mv $DATA/${file} $COMOUT/$cyc/ensstat/ensstat_grb2${ext_h}.$cycle.$file
#		mv $DATA/${file}.idx $COMOUT/$cyc/ensstat/ensstat_grb2${ext_h}.$cycle.${file}.idx
#		mv $DATA/${file}_grb1 $COMOUT/$cyc/ensstat/ensstat${ext_h}.$cycle.$file
#		mv $DATA/${file}i_grb1 $COMOUT/$cyc/ensstat/ensstat${ext_h}.$cycle.${file}i
#	fi # [ $SENDCOM = "YES" ]
#done # for file in pqpf pqrf pqff pqsf pqif

############################################################################
###########  ADD DBN ALERTS FOR PPF AND PQPF FILES IF NEEDED  ##############
############################################################################

############################################################################
#   The following block is added in 2015 upgrade (when grib2 version is adopted) 
#   Generate (extra) grib1 version of output files and move them to /com 
############################################################################

for file in $postvarlist; do
	ln -s $COMOUT/$cyc/ensstat/enspost_grb2${ext_h}.${cycle}.${file} enspost_grb2${ext_h}.$cycle.${file}
	ln -s $COMOUT/$cyc/ensstat/ensstat_grb2${ext_h}.${cycle}.${file} ensstat_grb2${ext_h}.$cycle.${file}

	$WGRIB2 enspost_grb2${ext_h}.$cycle.${file} -s > enspost_grb2${ext_h}.$cycle.${file}.idx
	$WGRIB2 ensstat_grb2${ext_h}.$cycle.${file} -s > ensstat_grb2${ext_h}.$cycle.${file}.idx
	$CNVGRIB -g21 enspost_grb2${ext_h}.$cycle.${file} enspost${ext_h}.$cycle.${file}
	$CNVGRIB -g21 ensstat_grb2${ext_h}.$cycle.${file} ensstat${ext_h}.$cycle.${file}
	$GRBINDEX enspost${ext_h}.$cycle.${file}   enspost${ext_h}.$cycle.${file}i
	$GRBINDEX ensstat${ext_h}.$cycle.${file}   ensstat${ext_h}.$cycle.${file}i

	if [ "$SENDCOM" = "YES" ]; then
		#    mv enspost_grb2${ext_h}.$cycle.${file}  $COMOUT/$cyc/ensstat/enspost_grb2${ext_h}.${cycle}.${file}
		mv enspost_grb2${ext_h}.$cycle.${file}.idx $COMOUT/$cyc/ensstat/enspost_grb2${ext_h}.${cycle}.${file}.idx
		#    mv ensstat_grb2${ext_h}.$cycle.${file}  $COMOUT/$cyc/ensstat/ensstat_grb2${ext_h}.${cycle}.${file}
		mv ensstat_grb2${ext_h}.$cycle.${file}.idx $COMOUT/$cyc/ensstat/ensstat_grb2${ext_h}.${cycle}.${file}.idx
		mv enspost${ext_h}.$cycle.${file}  $COMOUT/$cyc/ensstat/enspost${ext_h}.${cycle}.${file}
		mv enspost${ext_h}.$cycle.${file}i $COMOUT/$cyc/ensstat/enspost${ext_h}.${cycle}.${file}i
		mv ensstat${ext_h}.$cycle.${file}  $COMOUT/$cyc/ensstat/ensstat${ext_h}.${cycle}.${file}
		mv ensstat${ext_h}.$cycle.${file}i $COMOUT/$cyc/ensstat/ensstat${ext_h}.${cycle}.${file}i
	fi # [ "$SENDCOM" = "YES" ]
done # for file in $postvarlist

msg="HAS COMPLETED NORMALLY!"
postmsg "$jlogfile" "$msg"
